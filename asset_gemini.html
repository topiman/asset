<script>
/*************************************************************
 * 0. 云端配置 (请替换这里!)
 *************************************************************/
const JSONBIN_ID  = "694a56ccae596e708fabeac2";       // 例如: 6760...
const JSONBIN_KEY = "$2a$10$ILS6zBz1bfayZ1p0fV2nw.aUVzyUXP6ZicSczS4LLMvPFuCDOY0JC";   // 例如: $2a$10$AbC...

// 这是一个标志位，防止云端数据还没加载完就覆盖了
let isDataLoaded = false;

/*************************************************************
 * A. 配置管理 & 云端同步
 *************************************************************/
const DEFAULT_CRYPTO = [
  { symbol: 'BTC',  wsKey: 'btcusdt' },
  { symbol: 'ETH',  wsKey: 'ethusdt' },
  { symbol: 'SOL',  wsKey: 'solusdt' },
  { symbol: 'USDT', wsKey: null, isStable: true }
];
const DEFAULT_STOCK = [
  { symbol: 'TSLA' },
  { symbol: 'NVDA' },
  { symbol: 'USD', isCash: true }
];

let cryptoConfig = [];
let stockConfig = [];
let prices = {};
let quantities = {};
let hourlyComb = []; // 历史走势（因为体积大，建议只在本地存，或者也上传）

const FINNHUB_TOKEN = "cuhf9e9r01qva71tls00cuhf9e9r01qva71tls0g";
const MAX_HOUR_LEN = 8760; 

let cryptoWS = null;
let chartLine, chartPie;
let stockInterval = null;

// ★★★ 核心修改：从云端读取数据 ★★★
async function loadConfig() {
  $('#wsStatusText').text('正在从云端同步数据...');
  
  try {
    const res = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_ID}/latest`, {
      method: 'GET',
      headers: {
        'X-Master-Key': JSONBIN_KEY
      }
    });

    if (!res.ok) throw new Error('云端连接失败');
    
    const json = await res.json();
    const data = json.record; // JSONBin 的数据在 record 字段里

    // 如果云端是空的（第一次），使用默认值
    cryptoConfig = data.cryptoConfig || JSON.parse(JSON.stringify(DEFAULT_CRYPTO));
    stockConfig  = data.stockConfig  || JSON.parse(JSON.stringify(DEFAULT_STOCK));
    quantities   = data.quantities   || {};
    
    // 初始化价格
    [...cryptoConfig, ...stockConfig].forEach(item => {
      const key = item.symbol.toLowerCase();
      if (quantities[key] === undefined) quantities[key] = 0;
      if (item.isStable || item.isCash) prices[key] = 1;
      else if (!prices[key]) prices[key] = 0;
    });

    // 历史数据体积较大，如果你想多端同步历史图表，也可以放在 cloud 里
    // 这里为了演示简单，假设历史数据也同步
    if (Array.isArray(data.hourlyComb)) {
      hourlyComb = data.hourlyComb;
    } else {
      // 如果云端没有，尝试读本地缓存作为补充
      try {
        const localH = JSON.parse(localStorage.getItem('hourlyComb'));
        if(Array.isArray(localH)) hourlyComb = localH;
      } catch(e){}
    }

    isDataLoaded = true;
    renderUI();
    restartServices();
    initCharts(); // 数据拿到后再画图
    $('#wsStatusText').text('数据同步完成');

  } catch (err) {
    console.error(err);
    alert('无法读取云端数据，请检查 BIN_ID 和 API_KEY。将加载本地默认配置。');
    // 降级处理：读不到云端就读默认
    cryptoConfig = JSON.parse(JSON.stringify(DEFAULT_CRYPTO));
    stockConfig = JSON.parse(JSON.stringify(DEFAULT_STOCK));
    renderUI();
    restartServices();
    initCharts();
  }
}

// ★★★ 核心修改：保存数据到云端 ★★★
// 每次修改配置或持仓时调用
async function saveToCloud() {
  if (!isDataLoaded) return; // 防止覆盖

  // 构造要保存的大对象
  const payload = {
    cryptoConfig: cryptoConfig,
    stockConfig: stockConfig,
    quantities: quantities,
    hourlyComb: hourlyComb // 包含历史走势
  };

  // 显示保存状态
  const originalText = $('#headerTotal').next().text(); // 获取当前按钮文字或其他状态
  
  try {
    const res = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_ID}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'X-Master-Key': JSONBIN_KEY
      },
      body: JSON.stringify(payload)
    });
    
    if(res.ok) {
      console.log('云端保存成功');
    }
  } catch(e) {
    console.error('云端保存失败', e);
    alert('保存失败，请检查网络');
  }
}

// 包装函数：保存配置
function saveConfig() {
  // 本地也存一份备份
  localStorage.setItem('v4_crypto_config', JSON.stringify(cryptoConfig));
  renderUI();
  restartServices();
  saveToCloud(); // 上传
}

// 包装函数：保存持仓
function saveHoldings() {
  // 本地也存一份备份
  localStorage.setItem('v4_holdings', JSON.stringify(quantities));
  saveToCloud(); // 上传
}

/*************************************************************
 * B. 模态框逻辑 (UI Interaction)
 *************************************************************/
function openConfigModal() { $('#configModal').css('display', 'flex'); renderConfigList(); }
function closeConfigModal() { $('#configModal').hide(); }

function renderConfigList() {
  const $cList = $('#cryptoConfigList').empty();
  cryptoConfig.forEach((item, idx) => {
    $cList.append(`
      <li class="config-item">
        <span>${item.symbol}</span>
        ${item.symbol !== 'USDT' ? `<i class="fas fa-trash-alt btn-delete" onclick="removeCrypto(${idx})"></i>` : ''}
      </li>
    `);
  });

  const $sList = $('#stockConfigList').empty();
  stockConfig.forEach((item, idx) => {
    $sList.append(`
      <li class="config-item">
        <span>${item.symbol}</span>
        ${item.symbol !== 'USD' ? `<i class="fas fa-trash-alt btn-delete" onclick="removeStock(${idx})"></i>` : ''}
      </li>
    `);
  });
}

function addCryptoAsset() {
  const sym = $('#newCryptoSymbol').val().toUpperCase().trim();
  if(!sym) return;
  if(cryptoConfig.find(c => c.symbol === sym)) { alert('已存在'); return; }
  cryptoConfig.push({ symbol: sym, wsKey: sym.toLowerCase() + 'usdt' });
  $('#newCryptoSymbol').val('');
  renderConfigList(); saveConfig();
}
function removeCrypto(idx) { cryptoConfig.splice(idx, 1); renderConfigList(); saveConfig(); }

function addStockAsset() {
  const sym = $('#newStockSymbol').val().toUpperCase().trim();
  if(!sym) return;
  if(stockConfig.find(s => s.symbol === sym)) { alert('已存在'); return; }
  stockConfig.push({ symbol: sym });
  $('#newStockSymbol').val('');
  renderConfigList(); saveConfig();
}
function removeStock(idx) { stockConfig.splice(idx, 1); renderConfigList(); saveConfig(); }

function resetToDefault() {
  if(confirm('警告：这会重置云端的所有配置！确定吗？')) {
    cryptoConfig = JSON.parse(JSON.stringify(DEFAULT_CRYPTO));
    stockConfig = JSON.parse(JSON.stringify(DEFAULT_STOCK));
    quantities = {};
    saveConfig(); // 立即同步到云端
    saveHoldings();
    location.reload();
  }
}

/*************************************************************
 * C. 主界面渲染
 *************************************************************/
function renderUI() {
  const $cIn = $('#cryptoInputs').empty();
  const $cTb = $('#cryptoTableBody').empty();
  
  cryptoConfig.forEach(c => {
    const key = c.symbol.toLowerCase();
    $cIn.append(`
      <div class="input-group">
        <label>${c.symbol}</label>
        <input type="number" step="any" data-key="${key}" value="${quantities[key]}">
      </div>`);
    $cTb.append(`
      <tr>
        <td><b>${c.symbol}</b></td>
        <td class="val-cell" id="p_${key}">--</td>
        <td class="val-cell" id="q_${key}">${quantities[key]}</td>
        <td class="val-cell" id="v_${key}">--</td>
      </tr>`);
  });

  const $sIn = $('#stockInputs').empty();
  const $sTb = $('#stockTableBody').empty();
  
  stockConfig.forEach(s => {
    const key = s.symbol.toLowerCase();
    $sIn.append(`
      <div class="input-group">
        <label>${s.symbol}</label>
        <input type="number" step="any" data-key="${key}" value="${quantities[key]}">
      </div>`);
    $sTb.append(`
      <tr>
        <td><b>${s.symbol}</b></td>
        <td class="val-cell" id="p_${key}">${s.isCash?'1.00':'--'}</td>
        <td class="val-cell" id="q_${key}">${quantities[key]}</td>
        <td class="val-cell" id="v_${key}">--</td>
      </tr>`);
  });

  $('input[type="number"]').off('input').on('input', function() {
    const k = $(this).data('key');
    quantities[k] = parseFloat($(this).val()) || 0;
    $(`#q_${k}`).text(quantities[k]);
    recalc();
    // 做了防抖处理，防止输入一个数字就请求一次云端，这里简化处理：
    // 实际使用建议加 debounce，这里为了简单，每次输入都存一下（JSONBin频率限制较高没事）
    saveHoldings(); 
  });
}

function recalc() {
  let cTotal = 0, sTotal = 0;
  
  cryptoConfig.forEach(c => {
    const k = c.symbol.toLowerCase();
    const p = prices[k]||0; const q = quantities[k]||0;
    const v = p*q;
    cTotal += v;
    $(`#p_${k}`).text(p>0 ? p.toFixed(p<1?4:2) : '--');
    $(`#v_${k}`).text(v.toFixed(2));
  });

  stockConfig.forEach(s => {
    const k = s.symbol.toLowerCase();
    const p = prices[k]||0; const q = quantities[k]||0;
    const v = p*q;
    sTotal += v;
    if(!s.isCash) $(`#p_${k}`).text(p>0?p.toFixed(2):'--');
    $(`#v_${k}`).text(v.toFixed(2));
  });

  const all = cTotal + sTotal;
  $('#cryptoTotalDisplay').text(cTotal.toFixed(2));
  $('#stockTotalDisplay').text(sTotal.toFixed(2));
  $('#headerTotal').text(all.toLocaleString('en-US',{style:'currency',currency:'USD'}));
  
  updatePieChart(all);
}

/*************************************************************
 * D. 服务连接
 *************************************************************/
function restartServices() {
  if(cryptoWS) cryptoWS.close();
  startBinanceWS();
  if(stockInterval) clearInterval(stockInterval);
  fetchStockPrices();
  stockInterval = setInterval(fetchStockPrices, 30000);
}

function startBinanceWS() {
  const streams = cryptoConfig
    .filter(c => c.wsKey)
    .map(c => c.wsKey + '@ticker')
    .join('/');
  
  if(!streams) return;

  $('#wsStatusText').text('连接中...');
  $('#wsDot').removeClass('active');
  
  cryptoWS = new WebSocket("wss://stream.binance.com:9443/stream?streams=" + streams);
  
  cryptoWS.onopen = () => { $('#wsStatusText').text('已连接'); $('#wsDot').addClass('active'); };
  cryptoWS.onmessage = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      const symbol = cryptoConfig.find(c => c.wsKey && msg.stream.includes(c.wsKey));
      if(symbol) {
        prices[symbol.symbol.toLowerCase()] = parseFloat(msg.data.c);
        recalc();
      }
    } catch(e){}
  };
}

async function fetchStockPrices() {
  $('#apiDot').removeClass('active');
  const symbols = stockConfig.filter(s => !s.isCash).map(s => s.symbol);
  if(symbols.length === 0) return;

  const promises = symbols.map(sym => 
    fetch(`https://finnhub.io/api/v1/quote?symbol=${sym}&token=${FINNHUB_TOKEN}`)
      .then(r => r.json())
      .then(d => ({s: sym, p: d.c}))
      .catch(()=>null)
  );

  const res = await Promise.all(promises);
  res.forEach(r => {
    if(r && r.p) prices[r.s.toLowerCase()] = r.p;
  });
  $('#apiDot').addClass('active');
  recalc();
}

/*************************************************************
 * E. 图表逻辑
 *************************************************************/
function initCharts() {
  // 如果图表已经存在，销毁它重建
  if(chartLine) chartLine.destroy();
  if(chartPie) chartPie.destroy();

  const ctxLine = document.getElementById('chartHourComb').getContext('2d');
  chartLine = new Chart(ctxLine, {
    type: 'line',
    data: {
      datasets: [{
        label: '总资产', data: hourlyComb,
        borderColor: '#38bdf8', backgroundColor: 'rgba(56, 189, 248, 0.1)',
        fill: true, tension: 0.4, parsing: { xAxisKey: 'x', yAxisKey: 'y' }
      }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: { x: { display: false }, y: { position: 'right' } }
    }
  });

  const ctxPie = document.getElementById('chartAssetPie').getContext('2d');
  chartPie = new Chart(ctxPie, {
    type: 'doughnut',
    data: { 
      labels: [], 
      datasets: [{ 
        data: [], 
        borderWidth: 0, 
        backgroundColor: ['#38bdf8','#4ade80','#fbbf24','#f87171','#a78bfa','#2dd4bf','#fb923c','#94a3b8'] 
      }] 
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: {
        legend: { position: 'right', labels: { boxWidth: 10, color: '#94a3b8' } },
        tooltip: {
          callbacks: {
            label: function(context) {
              let label = context.label || '';
              if (label) label += ': ';
              const value = context.parsed;
              const total = context.dataset.data.reduce((acc, curr) => acc + curr, 0);
              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
              const formattedVal = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
              return `${label}${formattedVal} (${percentage})`;
            }
          }
        }
      }
    }
  });
}

function updatePieChart(totalVal) {
  if(!chartPie) return;
  let labels = [], data = [];
  [...cryptoConfig, ...stockConfig].forEach(item => {
    const k = item.symbol.toLowerCase();
    const v = (prices[k]||0) * (quantities[k]||0);
    if(v > 10) { labels.push(item.symbol); data.push(v); }
  });
  chartPie.data.labels = labels;
  chartPie.data.datasets[0].data = data;
  chartPie.update();
}

function recordHistory() {
  if(!isDataLoaded) return; // 数据没加载完别记录

  const currentTotal = [...cryptoConfig, ...stockConfig].reduce((acc, item) => {
    const k = item.symbol.toLowerCase();
    return acc + ((prices[k]||0) * (quantities[k]||0));
  }, 0);

  const d = new Date();
  const label = `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()} ${d.getHours()}:00`;
  
  // 如果是新的小时点，记录并上传
  if (hourlyComb.length === 0 || hourlyComb[hourlyComb.length-1].x !== label) {
    hourlyComb.push({ x: label, y: currentTotal });
    if(hourlyComb.length > MAX_HOUR_LEN) hourlyComb.shift();
    
    // 更新图表
    chartLine.data.datasets[0].data = hourlyComb;
    chartLine.update();
    
    // 同步到云端
    saveToCloud();
  }
}

/*************************************************************
 * Init
 *************************************************************/
window.onload = function() {
  // 注意：我们不再直接调用 renderUI，而是先 loadConfig，成功后再 renderUI
  loadConfig();
  
  // 定时记录历史
  setInterval(recordHistory, 10000);
};
</script>
